# MEME Launchpad 功能详情文档

## 目录

1. [系统架构](#系统架构)
2. [代币创建功能](#代币创建功能)
3. [Bonding Curve 交易功能](#bonding-curve-交易功能)
4. [代币毕业功能](#代币毕业功能)
5. [代币归属功能](#代币归属功能)
6. [费用管理功能](#费用管理功能)
7. [紧急暂停功能](#紧急暂停功能)
8. [权限管理功能](#权限管理功能)
9. [多链支持](#多链支持)

---

## 系统架构

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                         用户界面                              │
│                   (Web3 DApp / 前端)                        │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                      MEMECore                                │
│  (核心合约 - 代币管理、交易、毕业)                            │
└─────────┬──────────────┬──────────────┬─────────────────────┘
          │              │              │
          ▼              ▼              ▼
┌─────────────────┐ ┌──────────────┐ ┌──────────────────┐
│  MEMEFactory    │ │ MEMEHelper   │ │  MEMEVesting     │
│  (工厂合约)      │ │ (辅助合约)    │ │  (归属合约)       │
└─────────────────┘ └──────┬───────┘ └──────────────────┘
                           │
                           ▼
                  ┌────────────────┐
                  │  PancakeSwap   │
                  │  (DEX 路由器)   │
                  └────────────────┘
```

### 合约交互流程

1. **创建代币流程**：
   - 用户调用 `MEMECore.createToken()`
   - `MEMECore` 调用 `MEMEFactory.deployToken()` 部署代币合约
   - `MEMECore` 初始化代币信息和 Bonding Curve 参数
   - `MEMECore` 调用 `MEMEVesting` 创建归属计划

2. **交易流程**：
   - 用户调用 `MEMECore.buy()` 或 `MEMECore.sell()`
   - `MEMECore` 调用 `MEMEHelper` 计算交易数量
   - `MEMECore` 执行代币转账和费用分配
   - `MEMEToken` 更新余额

3. **毕业流程**：
   - 用户或系统调用 `MEMECore.graduate()`
   - `MEMECore` 调用 `MEMEHelper.addLiquidity()` 添加流动性
   - `MEMECore` 更新代币状态为 GRADUATED
   - `MEMEToken` 切换到正常转账模式

---

## 代币创建功能

### 功能概述

代币创建功能允许用户通过 MEME Launchpad 平台创建新的 MEME 代币。每个代币都使用 Bonding Curve 机制进行定价，并可以在满足条件后自动"毕业"到 DEX。

### 核心函数

#### createToken()

```solidity
/**
 * @notice 创建新代币
 * @dev 防重入、暂停保护
 * 
 * @param data ABI 编码的 CreateTokenParams
 * @param signature 后端对 data+chainId+address 的签名
 * @return tokenAddress 新部署的代币合约地址
 */
function createToken(
    bytes calldata data,
    bytes calldata signature
) external payable nonReentrant whenNotPaused returns (address tokenAddress)
```

**参数说明**：

```solidity
struct CreateTokenParams {
    string name;                    // 代币名称
    string symbol;                  // 代币符号
    string description;             // 代币描述
    string image;                   // 代币图片 URL
    address twitter;                // Twitter 账号
    address telegram;               // Telegram 账号
    uint256 totalSupply;            // 总供应量
    uint256 virtualBNBReserve;      // 虚拟 BNB 储备
    uint256 virtualTokenReserve;    // 虚拟代币储备
    VestingParams vestingParams;    // 归属参数
    uint256 timestamp;              // 时间戳（用于 CREATE2）
    uint256 nonce;                  // 随机数（用于 CREATE2）
}
```

**返回值**：
- `tokenAddress`：新部署的代币合约地址

**执行流程**：

1. **参数解码**：
   ```solidity
   CreateTokenParams memory params = abi.decode(data, (CreateTokenParams));
   ```

2. **签名验证**：
   ```solidity
   bytes32 messageHash = keccak256(abi.encodePacked(
       data,
       block.chainid,
       msg.sender
   ));
   bytes32 ethSignedMessageHash = keccak256(abi.encodePacked(
       "\x19Ethereum Signed Message:\n32",
       messageHash
   ));
   address signer = recoverSigner(ethSignedMessageHash, signature);
   require(signer == authorizedSigner, "Invalid signature");
   ```

3. **部署代币合约**：
   ```solidity
   tokenAddress = factory.deployToken(
       params.name,
       params.symbol,
       params.totalSupply,
       params.timestamp,
       params.nonce
   );
   ```

4. **初始化代币信息**：
   ```solidity
   tokens[tokenAddress] = TokenInfo({
       creator: msg.sender,
       tokenAddress: tokenAddress,
       totalSupply: params.totalSupply,
       availableSupply: params.totalSupply,
       virtualBNBReserve: params.virtualBNBReserve,
       virtualTokenReserve: params.virtualTokenReserve,
       status: TokenStatus.TRADING,
       creationTime: block.timestamp
   });
   ```

5. **创建归属计划**：
   ```solidity
   vesting.createVestingPlan(
       tokenAddress,
       params.vestingParams
   );
   ```

6. **分配初始代币**：
   ```solidity
   IMEMEToken(tokenAddress).transfer(msg.sender, initialAmount);
   ```

**Gas 消耗**：
- 部署代币合约：~2,000,000 gas
- 初始化代币信息：~100,000 gas
- 创建归属计划：~150,000 gas
- **总计**：~2,250,000 gas

**注意事项**：
- 必须提供有效的后端签名
- 代币名称和符号不能为空
- 总供应量必须大于 0
- 虚拟储备参数必须合理（不能为 0）

### CREATE2 地址预测

**原理**：
CREATE2 操作码允许在部署合约之前预测其地址，地址由以下公式计算：

```
address = keccak256(0xff + sender + salt + keccak256(init_code))[12:]
```

**实现**：

```solidity
function predictTokenAddress(
    string memory name,
    string memory symbol,
    uint256 totalSupply,
    uint256 timestamp,
    uint256 nonce
) external view returns (address) {
    bytes32 salt = keccak256(abi.encodePacked(timestamp, nonce));
    bytes32 initCodeHash = keccak256(abi.encodePacked(
        type(MEMEToken).creationCode,
        abi.encode(name, symbol, totalSupply, address(memeCore))
    ));
    
    return address(uint160(uint256(keccak256(abi.encodePacked(
        hex"d694",
        address(this),
        salt,
        initCodeHash
    )))));
}
```

**优势**：
- 地址可预测，可以提前授权
- 避免地址冲突
- 支持跨链部署相同地址

---

## Bonding Curve 交易功能

### 功能概述

Bonding Curve 是一种自动定价机制，通过数学公式确定代币价格。随着代币供应量的变化，价格自动调整。

### 核心公式

**恒定乘积公式**：

```
k = virtualBNBReserve × virtualTokenReserve
```

**买入公式**：

```
newBNBReserve = virtualBNBReserve + bnbIn
newTokenReserve = k / newBNBReserve
tokenOut = virtualTokenReserve - newTokenReserve
```

**卖出公式**：

```
newTokenReserve = virtualTokenReserve + tokenIn
newBNBReserve = k / newTokenReserve
bnbOut = virtualBNBReserve - newBNBReserve
```

### 买入功能

#### buy()

```solidity
/**
 * @notice 通过 Bonding Curve 买入代币
 * @dev 防重入、暂停保护
 * 
 * @param tokenAddress 代币地址
 * @param minTokenOut 最小代币输出量（滑点保护）
 * @param referral 推荐人地址
 * @return tokenOut 实际获得的代币数量
 */
function buy(
    address tokenAddress,
    uint256 minTokenOut,
    address referral
) external payable nonReentrant whenNotPaused returns (uint256 tokenOut)
```

**执行流程**：

1. **验证代币状态**：
   ```solidity
   require(tokens[tokenAddress].status == TokenStatus.TRADING, "Token not trading");
   ```

2. **计算代币输出量**：
   ```solidity
   TokenInfo memory tokenInfo = tokens[tokenAddress];
   BondingCurveParams memory curve = BondingCurveParams({
       virtualBNBReserve: tokenInfo.virtualBNBReserve,
       virtualTokenReserve: tokenInfo.virtualTokenReserve
   });
   
   uint256 bnbIn = msg.value;
   tokenOut = helper.calculateTokenAmountOut(bnbIn, curve);
   ```

3. **滑点保护**：
   ```solidity
   require(tokenOut >= minTokenOut, "Slippage exceeded");
   ```

4. **计算费用**：
   ```solidity
   uint256 protocolFee = (bnbIn * protocolFeeRate) / 10000;
   uint256 creatorFee = (bnbIn * creatorFeeRate) / 10000;
   uint256 referralFee = (bnbIn * referralFeeRate) / 10000;
   uint256 bnbForCurve = bnbIn - protocolFee - creatorFee - referralFee;
   ```

5. **更新虚拟储备**：
   ```solidity
   tokens[tokenAddress].virtualBNBReserve += bnbForCurve;
   tokens[tokenAddress].virtualTokenReserve -= tokenOut;
   ```

6. **转账代币**：
   ```solidity
   IMEMEToken(tokenAddress).transfer(msg.sender, tokenOut);
   ```

7. **分配费用**：
   ```solidity
   payable(protocolFeeRecipient).transfer(protocolFee);
   payable(tokens[tokenAddress].creator).transfer(creatorFee);
   if (referral != address(0)) {
       payable(referral).transfer(referralFee);
   }
   ```

8. **检查毕业条件**：
   ```solidity
   if (tokens[tokenAddress].availableSupply <= graduationThreshold) {
       tokens[tokenAddress].status = TokenStatus.PENDING_GRADUATION;
   }
   ```

**价格计算示例**：

假设：
- virtualBNBReserve = 10 BNB
- virtualTokenReserve = 1,000,000 代币
- 用户买入 1 BNB

计算过程：
```
k = 10 × 1,000,000 = 10,000,000
newBNBReserve = 10 + 1 = 11 BNB
newTokenReserve = 10,000,000 / 11 = 909,090.91 代币
tokenOut = 1,000,000 - 909,090.91 = 90,909.09 代币
```

**价格曲线**：

```
价格
  ↑
  │    ╱╲
  │   ╱  ╲
  │  ╱    ╲
  │ ╱      ╲
  │╱________╲_______ 代币数量
  0
```

### 卖出功能

#### sell()

```solidity
/**
 * @notice 通过 Bonding Curve 卖出代币
 * @dev 防重入、暂停保护
 * 
 * @param tokenAddress 代币地址
 * @param tokenIn 卖出的代币数量
 * @param minBNBOut 最小 BNB 输出量（滑点保护）
 * @return bnbOut 实际获得的 BNB 数量
 */
function sell(
    address tokenAddress,
    uint256 tokenIn,
    uint256 minBNBOut
) external nonReentrant whenNotPaused returns (uint256 bnbOut)
```

**执行流程**：

1. **验证代币状态**：
   ```solidity
   require(tokens[tokenAddress].status == TokenStatus.TRADING, "Token not trading");
   ```

2. **计算 BNB 输出量**：
   ```solidity
   TokenInfo memory tokenInfo = tokens[tokenAddress];
   BondingCurveParams memory curve = BondingCurveParams({
       virtualBNBReserve: tokenInfo.virtualBNBReserve,
       virtualTokenReserve: tokenInfo.virtualTokenReserve
   });
   
   bnbOut = helper.calculateBNBAmountOut(tokenIn, curve);
   ```

3. **滑点保护**：
   ```solidity
   require(bnbOut >= minBNBOut, "Slippage exceeded");
   ```

4. **计算费用**：
   ```solidity
   uint256 protocolFee = (bnbOut * protocolFeeRate) / 10000;
   uint256 creatorFee = (bnbOut * creatorFeeRate) / 10000;
   uint256 bnbForUser = bnbOut - protocolFee - creatorFee;
   ```

5. **更新虚拟储备**：
   ```solidity
   tokens[tokenAddress].virtualBNBReserve -= bnbOut;
   tokens[tokenAddress].virtualTokenReserve += tokenIn;
   ```

6. **转账代币**：
   ```solidity
   IMEMEToken(tokenAddress).transferFrom(msg.sender, address(this), tokenIn);
   ```

7. **转账 BNB**：
   ```solidity
   payable(msg.sender).transfer(bnbForUser);
   payable(protocolFeeRecipient).transfer(protocolFee);
   payable(tokens[tokenAddress].creator).transfer(creatorFee);
   ```

**价格计算示例**：

假设：
- virtualBNBReserve = 11 BNB
- virtualTokenReserve = 909,090.91 代币
- 用户卖出 90,909.09 代币

计算过程：
```
k = 11 × 909,090.91 = 10,000,000
newTokenReserve = 909,090.91 + 90,909.09 = 1,000,000 代币
newBNBReserve = 10,000,000 / 1,000,000 = 10 BNB
bnbOut = 11 - 10 = 1 BNB
```

### 滑点保护

**原理**：
由于区块链交易存在确认延迟，实际执行时的价格可能与用户预期不同。滑点保护机制确保用户不会以不利的价格交易。

**实现**：

```solidity
// 用户指定最小输出量
uint256 minTokenOut = expectedTokenOut * (10000 - slippageTolerance) / 10000;

// 执行交易
uint256 actualTokenOut = buy(tokenAddress, minTokenOut, referral);

// 如果实际输出量小于最小输出量，交易回滚
require(actualTokenOut >= minTokenOut, "Slippage exceeded");
```

**滑点设置建议**：
- 低波动性代币：0.5% - 1%
- 高波动性代币：3% - 5%
- 极端情况：10%+

---

## 代币毕业功能

### 功能概述

当代币的可售供应量低于阈值时，代币会自动"毕业"。毕业意味着将流动性从 Bonding Curve 转移到 PancakeSwap 等 DEX，代币进入自由交易阶段。

### 毕业条件

```solidity
/**
 * @notice 检查代币是否可以毕业
 * @dev 当可售供应量低于阈值时可以毕业
 * 
 * @param tokenAddress 代币地址
 * @return 是否可以毕业
 */
function canGraduate(address tokenAddress) public view returns (bool) {
    TokenInfo memory tokenInfo = tokens[tokenAddress];
    return tokenInfo.status == TokenStatus.TRADING &&
           tokenInfo.availableSupply <= graduationThreshold;
}
```

**默认阈值**：
- graduationThreshold = totalSupply × 10%

### 毕业流程

#### graduate()

```solidity
/**
 * @notice 将代币流动性转移到 DEX
 * @dev 防重入、暂停保护
 * 
 * @param tokenAddress 代币地址
 * @return pairAddress DEX 交易对地址
 */
function graduate(address tokenAddress) external nonReentrant whenNotPaused returns (address pairAddress)
```

**执行流程**：

1. **验证毕业条件**：
   ```solidity
   require(canGraduate(tokenAddress), "Token cannot graduate");
   ```

2. **计算流动性**：
   ```solidity
   TokenInfo memory tokenInfo = tokens[tokenAddress];
   uint256 bnbAmount = tokenInfo.virtualBNBReserve;
   uint256 tokenAmount = tokenInfo.virtualTokenReserve;
   ```

3. **授权 DEX 路由器**：
   ```solidity
   IMEMEToken(tokenAddress).approve(address(pancakeRouter), tokenAmount);
   ```

4. **添加流动性到 DEX**：
   ```solidity
   (uint256 amountToken, uint256 amountBNB, uint256 liquidity) = 
       helper.addLiquidity(
           tokenAddress,
           address(wbnb),
           tokenAmount,
           bnbAmount,
           0,  // minAmountToken
           0,  // minAmountBNB
           address(this),
           block.timestamp
       );
   ```

5. **获取交易对地址**：
   ```solidity
   pairAddress = pancakeFactory.getPair(tokenAddress, address(wbnb));
   ```

6. **更新代币状态**：
   ```solidity
   tokens[tokenAddress].status = TokenStatus.GRADUATED;
   tokens[tokenAddress].availableSupply = 0;
   ```

7. **切换代币转账模式**：
   ```solidity
   IMEMEToken(tokenAddress).setTransferMode(IMEMEToken.TransferMode.MODE_NORMAL);
   ```

8. **发送流动性代币**：
   ```solidity
   IERC20(pairAddress).transfer(tokens[tokenAddress].creator, liquidity);
   ```

**Gas 消耗**：
- 授权：~46,000 gas
- 添加流动性：~250,000 gas
- 更新状态：~50,000 gas
- **总计**：~346,000 gas

### 毕业后交易

**交易方式变化**：

| 阶段 | 交易方式 | 价格机制 | 转账限制 |
|------|---------|---------|---------|
| 毕业前 | Bonding Curve | 自动定价 | 受控模式 |
| 毕业后 | PancakeSwap | 市场定价 | 自由转账 |

**用户操作**：

1. **通过 DEX 交易**：
   ```solidity
   // 在 PancakeSwap 上交易
   pancakeRouter.swapExactETHForTokens(
       minTokenOut,
       [address(wbnb), tokenAddress],
       msg.sender,
       block.timestamp
   );
   ```

2. **直接转账**：
   ```solidity
   // 毕业后可以自由转账
   IMEMEToken(tokenAddress).transfer(recipient, amount);
   ```

---

## 代币归属功能

### 功能概述

代币归属功能允许创建者设置代币的释放计划，防止代币过早流通影响价格稳定性。

### 归属模式

#### 1. 销毁模式（BURN）

**特点**：
- 代币永久销毁
- 不参与流通
- 减少总供应量

**实现**：

```solidity
function releaseBURN(
    address tokenAddress,
    bytes32 uid
) external {
    VestingPlan memory plan = vestingPlans[tokenAddress][uid];
    
    require(plan.mode == VestingMode.BURN, "Invalid vesting mode");
    
    // 销毁代币
    IMEMEToken(tokenAddress).burn(plan.amount);
    
    delete vestingPlans[tokenAddress][uid];
}
```

**使用场景**：
- 团队激励代币
- 生态建设基金
- 长期持有奖励

#### 2. 悬崖模式（CLIFF）

**特点**：
- 到期一次性释放全部代币
- 适合短期激励
- 简单易理解

**实现**：

```solidity
function releaseCLIFF(
    address tokenAddress,
    bytes32 uid
) external {
    VestingPlan memory plan = vestingPlans[tokenAddress][uid];
    
    require(plan.mode == VestingMode.CLIFF, "Invalid vesting mode");
    require(block.timestamp >= plan.cliffTime, "Cliff not reached");
    
    // 释放全部代币
    IMEMEToken(tokenAddress).transfer(plan.beneficiary, plan.amount);
    
    delete vestingPlans[tokenAddress][uid];
}
```

**使用场景**：
- 早期投资者
- 顾问奖励
- 里程碑奖励

#### 3. 线性模式（LINEAR）

**特点**：
- 按时间比例逐步释放
- 防止代币集中抛售
- 价格影响更平滑

**实现**：

```solidity
function releaseLINEAR(
    address tokenAddress,
    bytes32 uid
) external returns (uint256 amount) {
    VestingPlan memory plan = vestingPlans[tokenAddress][uid];
    
    require(plan.mode == VestingMode.LINEAR, "Invalid vesting mode");
    
    // 计算已释放数量
    uint256 timeElapsed = block.timestamp - plan.startTime;
    uint256 totalDuration = plan.endTime - plan.startTime;
    
    if (timeElapsed >= totalDuration) {
        // 归属期结束，释放剩余代币
        amount = plan.amount - plan.releasedAmount;
    } else {
        // 按比例释放
        amount = (plan.amount * timeElapsed) / totalDuration - plan.releasedAmount;
    }
    
    require(amount > 0, "Nothing to release");
    
    // 更新已释放数量
    vestingPlans[tokenAddress][uid].releasedAmount += amount;
    
    // 转账代币
    IMEMEToken(tokenAddress).transfer(plan.beneficiary, amount);
}
```

**使用场景**：
- 团队成员薪酬
- 长期投资者
- 生态合作伙伴

### 归属参数

```solidity
struct VestingParams {
    VestingMode mode;      // 归属模式
    uint256 amount;        // 归属数量
    uint256 cliffTime;     // 悬崖时间（CLIFF 模式）
    uint256 startTime;     // 开始时间（LINEAR 模式）
    uint256 endTime;       // 结束时间（LINEAR 模式）
    address beneficiary;   // 受益人地址
}
```

### 创建归属计划

```solidity
/**
 * @notice 创建归属计划
 * 
 * @param tokenAddress 代币地址
 * @param params 归属参数
 * @return uid 归属计划唯一标识
 */
function createVestingPlan(
    address tokenAddress,
    VestingParams calldata params
) external returns (bytes32 uid) {
    // 生成唯一标识
    uid = keccak256(abi.encodePacked(
        tokenAddress,
        params.beneficiary,
        block.timestamp
    ));
    
    // 存储归属计划
    vestingPlans[tokenAddress][uid] = VestingPlan({
        mode: params.mode,
        amount: params.amount,
        cliffTime: params.cliffTime,
        startTime: params.startTime,
        endTime: params.endTime,
        beneficiary: params.beneficiary,
        releasedAmount: 0
    });
    
    emit VestingPlanCreated(tokenAddress, uid, params);
}
```

### 归属释放流程

```
开始时间 → 悬崖时间 → 结束时间
    │           │           │
    │           │           └─ 全部释放
    │           └─ 一次性释放（CLIFF）
    └─ 按比例释放（LINEAR）
```

### 归属计算示例

**线性模式示例**：

假设：
- 总量：1,000,000 代币
- 开始时间：2024-01-01
- 结束时间：2024-12-31
- 当前时间：2024-07-01

计算过程：
```
总时长 = 366 天
已过时间 = 182 天
可释放比例 = 182 / 366 = 49.73%
可释放数量 = 1,000,000 × 49.73% = 497,267 代币
```

---

## 费用管理功能

### 功能概述

费用管理功能用于配置和分配平台交易产生的费用，包括协议费、创建者费和推荐费。

### 费用类型

#### 1. 协议费（Protocol Fee）

**说明**：
- 收取方：平台协议
- 用途：平台运营、开发、维护
- 默认费率：1%

**设置**：

```solidity
/**
 * @notice 设置协议费率
 * @dev 仅限管理员
 * 
 * @param newFeeRate 新费率（基点，100 = 1%）
 */
function setProtocolFee(uint256 newFeeRate) external onlyAdmin {
    require(newFeeRate <= 500, "Fee rate too high"); // 最高 5%
    protocolFeeRate = newFeeRate;
    emit ProtocolFeeUpdated(newFeeRate);
}
```

#### 2. 创建者费（Creator Fee）

**说明**：
- 收取方：代币创建者
- 用途：激励代币创建
- 默认费率：2%

**设置**：

```solidity
/**
 * @notice 设置创建者费率
 * @dev 仅限管理员
 * 
 * @param newFeeRate 新费率（基点，100 = 1%）
 */
function setCreatorFee(uint256 newFeeRate) external onlyAdmin {
    require(newFeeRate <= 1000, "Fee rate too high"); // 最高 10%
    creatorFeeRate = newFeeRate;
    emit CreatorFeeUpdated(newFeeRate);
}
```

#### 3. 推荐费（Referral Fee）

**说明**：
- 收取方：推荐人
- 用途：激励用户推荐
- 默认费率：0.5%

**设置**：

```solidity
/**
 * @notice 设置推荐费率
 * @dev 仅限管理员
 * 
 * @param newFeeRate 新费率（基点，100 = 1%）
 */
function setReferralFee(uint256 newFeeRate) external onlyAdmin {
    require(newFeeRate <= 500, "Fee rate too high"); // 最高 5%
    referralFeeRate = newFeeRate;
    emit ReferralFeeUpdated(newFeeRate);
}
```

### 费用分配

**买入交易费用分配**：

```solidity
function distributeBuyFees(
    uint256 bnbIn,
    address tokenAddress,
    address referral
) internal {
    // 计算各项费用
    uint256 protocolFee = (bnbIn * protocolFeeRate) / 10000;
    uint256 creatorFee = (bnbIn * creatorFeeRate) / 10000;
    uint256 referralFee = (bnbIn * referralFeeRate) / 10000;
    
    // 分配协议费
    if (protocolFee > 0) {
        payable(protocolFeeRecipient).transfer(protocolFee);
    }
    
    // 分配创建者费
    if (creatorFee > 0) {
        address creator = tokens[tokenAddress].creator;
        payable(creator).transfer(creatorFee);
    }
    
    // 分配推荐费
    if (referralFee > 0 && referral != address(0)) {
        payable(referral).transfer(referralFee);
    }
}
```

**卖出交易费用分配**：

```solidity
function distributeSellFees(
    uint256 bnbOut,
    address tokenAddress
) internal {
    // 计算各项费用
    uint256 protocolFee = (bnbOut * protocolFeeRate) / 10000;
    uint256 creatorFee = (bnbOut * creatorFeeRate) / 10000;
    
    // 分配协议费
    if (protocolFee > 0) {
        payable(protocolFeeRecipient).transfer(protocolFee);
    }
    
    // 分配创建者费
    if (creatorFee > 0) {
        address creator = tokens[tokenAddress].creator;
        payable(creator).transfer(creatorFee);
    }
}
```

### 费率配置示例

**保守配置**：
```
协议费：0.5%
创建者费：1%
推荐费：0.25%
总费率：1.75%
```

**标准配置**：
```
协议费：1%
创建者费：2%
推荐费：0.5%
总费率：3.5%
```

**激进配置**：
```
协议费：2%
创建者费：3%
推荐费：1%
总费率：6%
```

### 费用提取

```solidity
/**
 * @notice 提取累积费用
 * @dev 仅限费用接收者
 * 
 * @param tokenAddress 代币地址（address(0) 表示原生代币）
 * @param amount 提取数量
 */
function withdrawFees(address tokenAddress, uint256 amount) external {
    address recipient = msg.sender;
    
    if (tokenAddress == address(0)) {
        // 提取原生代币
        require(accumulatedFees[recipient] >= amount, "Insufficient balance");
        accumulatedFees[recipient] -= amount;
        payable(recipient).transfer(amount);
    } else {
        // 提取 ERC20 代币
        require(
            accumulatedTokenFees[tokenAddress][recipient] >= amount,
            "Insufficient balance"
        );
        accumulatedTokenFees[tokenAddress][recipient] -= amount;
        IERC20(tokenAddress).transfer(recipient, amount);
    }
    
    emit FeesWithdrawn(recipient, tokenAddress, amount);
}
```

---

## 紧急暂停功能

### 功能概述

紧急暂停功能允许管理员在发现安全漏洞或异常情况时，暂停所有交易操作，保护用户资产安全。

### 暂停机制

#### pause()

```solidity
/**
 * @notice 暂停合约
 * @dev 仅限管理员
 */
function pause() external onlyAdmin {
    _pause();
    emit ContractPaused(msg.sender, block.timestamp);
}
```

**影响范围**：
- 禁止创建新代币
- 禁止买入和卖出操作
- 禁止毕业操作
- 允许查询操作
- 允许提取资金

#### unpause()

```solidity
/**
 * @notice 恢复合约
 * @dev 仅限管理员
 */
function unpause() external onlyAdmin {
    _unpause();
    emit ContractUnpaused(msg.sender, block.timestamp);
}
```

**恢复范围**：
- 恢复所有正常操作
- 代币状态保持不变

### 暂停状态检查

```solidity
/**
 * @notice 检查合约是否暂停
 * @return 是否暂停
 */
function isPaused() external view returns (bool) {
    return _paused();
}
```

### 紧急提取

```solidity
/**
 * @notice 紧急提取资金
 * @dev 仅限管理员，仅在暂停状态下可用
 * 
 * @param tokenAddress 代币地址（address(0) 表示原生代币）
 * @param amount 提取数量
 * @param recipient 接收地址
 */
function emergencyWithdraw(
    address tokenAddress,
    uint256 amount,
    address recipient
) external onlyAdmin whenPaused {
    require(recipient != address(0), "Invalid recipient");
    
    if (tokenAddress == address(0)) {
        // 提取原生代币
        require(address(this).balance >= amount, "Insufficient balance");
        payable(recipient).transfer(amount);
    } else {
        // 提取 ERC20 代币
        require(
            IERC20(tokenAddress).balanceOf(address(this)) >= amount,
            "Insufficient balance"
        );
        IERC20(tokenAddress).transfer(recipient, amount);
    }
    
    emit EmergencyWithdraw(tokenAddress, amount, recipient);
}
```

### 暂停使用场景

1. **安全漏洞**：
   - 发现严重安全漏洞
   - 防止资产进一步损失

2. **异常交易**：
   - 检测到异常交易模式
   - 可能有攻击行为

3. **系统维护**：
   - 需要进行系统升级
   - 修复已知问题

4. **监管要求**：
   - 响应监管要求
   - 配合调查

### 暂停流程

```
发现问题 → 管理员暂停 → 分析问题 → 修复问题 → 恢复合约
```

### 注意事项

- 暂停前应发布公告
- 暂停时间应尽可能短
- 恢复前应充分测试
- 记录暂停和恢复原因

---

## 权限管理功能

### 功能概述

权限管理功能使用 OpenZeppelin 的 AccessControl 实现，基于角色的访问控制（RBAC），确保只有授权用户才能执行敏感操作。

### 角色定义

#### 1. DEFAULT_ADMIN_ROLE

**说明**：
- 最高权限角色
- 可以授予和撤销其他角色
- 可以执行所有管理操作

**权限**：
- 授予/撤销所有角色
- 设置费率
- 暂停/恢复合约
- 升级合约
- 紧急提取

#### 2. DEPLOYER_ROLE

**说明**：
- 代币部署角色
- 可以部署新的代币合约

**权限**：
- 部署代币合约
- 更新代币信息

#### 3. SIGNER_ROLE

**说明**：
- 签名验证角色
- 可以验证后端签名

**权限**：
- 验证创建代币签名
- 验证交易签名

### 角色授予

```solidity
/**
 * @notice 授予角色
 * @dev 仅限 DEFAULT_ADMIN_ROLE
 * 
 * @param role 角色
 * @param account 账户地址
 */
function grantRole(bytes32 role, address account) public override onlyRole(DEFAULT_ADMIN_ROLE) {
    _grantRole(role, account);
}
```

### 角色撤销

```solidity
/**
 * @notice 撤销角色
 * @dev 仅限 DEFAULT_ADMIN_ROLE
 * 
 * @param role 角色
 * @param account 账户地址
 */
function revokeRole(bytes32 role, address account) public override onlyRole(DEFAULT_ADMIN_ROLE) {
    _revokeRole(role, account);
}
```

### 权限检查

```solidity
/**
 * @notice 检查账户是否具有角色
 * 
 * @param role 角色
 * @param account 账户地址
 * @return 是否具有角色
 */
function hasRole(bytes32 role, address account) public view override returns (bool) {
    return _roles[role].members[account];
}
```

### 修饰符

```solidity
/**
 * @notice 仅限管理员
 */
modifier onlyAdmin() {
    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Not admin");
    _;
}

/**
 * @notice 仅限部署者
 */
modifier onlyDeployer() {
    require(hasRole(DEPLOYER_ROLE, msg.sender), "Not deployer");
    _;
}

/**
 * @notice 仅限签名者
 */
modifier onlySigner() {
    require(hasRole(SIGNER_ROLE, msg.sender), "Not signer");
    _;
}
```

### 权限管理最佳实践

1. **最小权限原则**：
   - 只授予必要的权限
   - 定期审查权限

2. **多签管理**：
   - 重要操作需要多个签名
   - 防止单点故障

3. **权限分离**：
   - 不同角色负责不同功能
   - 降低风险

4. **审计日志**：
   - 记录所有权限变更
   - 便于追踪和审计

---

## 多链支持

### 功能概述

MEME Launchpad 支持多条区块链网络，包括 BSC、Base、XLayer 等，实现跨链代币创建和交易。

### 支持的链

| 链名称 | Chain ID | RPC 端点 | 浏览器 |
|-------|---------|---------|--------|
| BSC | 56 | https://bsc-dataseed.binance.org/ | https://bscscan.com |
| Base | 8453 | https://mainnet.base.org | https://basescan.org |
| XLayer | 196 | https://rpc.xlayer.tech | https://explorer.xlayer.tech |
| BSC Testnet | 97 | https://data-seed-prebsc-1-s1.binance.org:8545/ | https://testnet.bscscan.com |
| Base Sepolia | 84532 | https://sepolia.base.org | https://sepolia.basescan.org |
| XLayer Testnet | 195 | https://rpc-test.xlayer.tech | https://explorer-test.xlayer.tech |

### 链配置

```solidity
struct ChainConfig {
    uint256 chainId;           // 链 ID
    string name;               // 链名称
    address wbnb;              // WBNB/WETH 地址
    address pancakeRouter;     // PancakeSwap 路由器地址
    address pancakeFactory;    // PancakeSwap 工厂地址
    uint256 gasPrice;          // Gas 价格
    uint256 gasLimit;          // Gas 限制
}
```

### 跨链部署

```solidity
/**
 * @notice 部署到指定链
 * 
 * @param chainId 链 ID
 * @param config 链配置
 */
function deployToChain(
    uint256 chainId,
    ChainConfig calldata config
) external onlyAdmin {
    // 验证链配置
    require(config.chainId == chainId, "Invalid chain ID");
    require(config.wbnb != address(0), "Invalid WBNB address");
    require(config.pancakeRouter != address(0), "Invalid router address");
    
    // 存储链配置
    chainConfigs[chainId] = config;
    
    emit ChainDeployed(chainId, config);
}
```

### 跨链验证

```solidity
/**
 * @notice 验证跨链交易
 * 
 * @param sourceChainId 源链 ID
 * @param targetChainId 目标链 ID
 * @param txHash 交易哈希
 * @return 是否有效
 */
function verifyCrossChainTx(
    uint256 sourceChainId,
    uint256 targetChainId,
    bytes32 txHash
) external view returns (bool) {
    // 验证链配置
    require(chainConfigs[sourceChainId].chainId == sourceChainId, "Invalid source chain");
    require(chainConfigs[targetChainId].chainId == targetChainId, "Invalid target chain");
    
    // 验证交易（需要桥接合约支持）
    // ...
    
    return true;
}
```

### 链切换

```solidity
/**
 * @notice 切换到指定链
 * 
 * @param chainId 链 ID
 */
function switchChain(uint256 chainId) external {
    require(chainConfigs[chainId].chainId == chainId, "Chain not supported");
    
    currentChainId = chainId;
    
    emit ChainSwitched(chainId, msg.sender);
}
```

### 多链部署脚本

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/MEMECore.sol";

contract DeployMultiChain is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        
        // BSC 主网
        vm.startBroadcast(deployerPrivateKey);
        deployToChain("bsc", 56);
        vm.stopBroadcast();
        
        // Base 主网
        vm.startBroadcast(deployerPrivateKey);
        deployToChain("base", 8453);
        vm.stopBroadcast();
        
        // XLayer 主网
        vm.startBroadcast(deployerPrivateKey);
        deployToChain("xlayer", 196);
        vm.stopBroadcast();
    }
    
    function deployToChain(string memory network, uint256 chainId) internal {
        // 部署逻辑
        // ...
    }
}
```

### 跨链注意事项

1. **Gas 限制**：
   - 不同链的 Gas 限制不同
   - 需要调整交易参数

2. **区块时间**：
   - 不同链的区块时间不同
   - 影响交易确认速度

3. **代币标准**：
   - 不同链可能使用不同的代币标准
   - 需要适配

4. **桥接支持**：
   - 跨链资产转移需要桥接合约
   - 确保桥接安全

---

## 总结

MEME Launchpad 是一个功能完整的代币启动平台，具有以下核心特性：

1. **代币创建**：使用 CREATE2 实现可预测地址部署
2. **Bonding Curve 交易**：自动定价机制，价格随供需变化
3. **自动毕业**：代币达到条件后自动转移到 DEX
4. **代币归属**：支持多种归属模式，保护价格稳定
5. **费用管理**：灵活的费用配置和分配机制
6. **紧急暂停**：保护用户资产安全
7. **权限管理**：基于角色的访问控制
8. **多链支持**：支持多条区块链网络

通过本文档，初级工程师可以理解 MEME Launchpad 的核心功能和实现原理，为后续的开发工作提供指导。
